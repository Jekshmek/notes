https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting/commit-level-operations


git checkout
    <sha>
        specific commit, endin up in a detached head state
    <tree-ish> -- <path>
        <tree-ish> refers to a commit hash, tag or branch,
        <path> is the path of the file relative to the top directory of the project

    -b <branch-name>
        checks out a branch [branch-to-start-from]
    -B <branch-name> <sha>
        ... at a specific <sha>

git checkout --track <remote>/<branch-name>
    create a branch which will track remote branch
    --track is needed if you have more than one remote, otherwise - by default


files reverting:
git checkout -- <file>
    check the <file> out to the latest state, known to git
git checkout -- .



UNSTAGING
git reset
    --soft  – The staged snapshot and working directory are not altered in any way.
    --mixed – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.
    --hard  – The staged snapshot and the working directory are both updated to match the specified commit.

git reset HEAD file
  rollback the <file> to a HEAD (current committed branch rev) state

  When invoked with a file path, git reset updates the staged snapshot to match the version from the specified commit.  
  The --soft, --mixed, and --hard flags do not have any effect on the file-level version of git reset,
  as the staged snapshot is always updated, and the working directory is never updated.

  rollback the indexation
git rm --cached database.yml
  remove from staging, leaving it at work-dir (to be added to .gitignore later)


git reset <commit>
  reset to commit
  result in a new dirty wrk dir in unsaved state
  undo a commits (they will be dangling and GC-ed the next time)
  
  use get checkout -- <file>
    to compeletely remove <file>

  git reflog can show us details about such tricks


  git checkout <commit-id>
  git rebase/merge <branch-name>
  git branch -d <branch-name>


File-level Operations:

The git reset and git checkout commands also accept an optional file path as a parameter.
This dramatically alters their behavior.
Instead of operating on entire snapshots, this forces them to limit their operations to a single file.


REVERTING:
Reverting undoes a commit by creating a new commit.
This is a safe way to undo changes, as it has no chance of re-writing the commit history. 

git revert <commit-id>
    reverts changes, made by the <commit-id>
    Note: do nota actually remove history log, like reset-cmd


Contrast this with git reset, which does alter the existing commit history.
For this reason, git revert should be used to undo changes on a public branch,
and git reset should be reserved for undoing changes on a private branch.

