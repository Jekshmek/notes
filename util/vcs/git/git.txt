Git manages tags/refs, pointing to the commit-objects, organized in a DAG-graph of trees, consisting of the smaller-trees and file-blobs objects (sometimes moved to a packs)

Articles
http://jaxenter.com/git-is-simple-on-the-inside-49426.html
http://wildlyinaccurate.com/a-hackers-guide-to-git

Presentations
http://talks.rosalab.com/20140823-05
https://speakerdeck.com/matthewmccullough/git-graphs-hashes-and-compression-oh-my-1 (http://youtu.be/ig5E8CcdM9g)
http://www.slideshare.net/chacon/git-101-presentation
http://www.slideshare.net/chacon/getting-git
  Slide 78 - Object database format

http://www.infoq.com/presentations/A-Tale-of-Three-Trees
  working-dir, index/staging, repo/head

Visualizations:
http://onlywei.github.io/explain-git-with-d3/
https://github.com/onlywei/explain-git-with-d3

man:
git everyday

RECOVERING
http://blog.ctp.com/2013/11/21/git-recovering-from-mistakes/


git fsck --full --strict
	to check the repo-validity

Every branch, tag, and other decoration is just a reference to the ID of a specific commit
(calculated with SHA-1, the secure hash algorithm).

git rev-parse <human-hash> or <branch-name>
	[pick out and massage parameters]
	to get a sys-id (long) from a human-readable (short) form

git rev-parse 'master^{tree}'
	.. commit tree

git describe --tags master
git describe --tags HEAD
	describe (find nearest tag) non-annotated tag


