Reese - Introduction to Dependent Types in Scala
http://wheaties.github.io/Presentations/Scala-Dep-Types/dependent-types.html#/
https://www.youtube.com/watch?v=cW4cmSWOSVA


trait DepValue{
    type V
    val value: V
}

def magic(that: DepValue): that.V = that.value

The return type of "magic" depends on the argument passed in.

- Toy Example

def mk[T](x: T) = new DepValue {
    type V = T
    val value = x
}

val depInt = mk(1)
val depString = mk("two")

val itWorks: Int = magic(depInt)
val again: String = magic(depString)


- Other Forms

trait Foo{
    class Bar
    def doNothing(b: Bar){}
}
val f1 = new Foo{}
val b1 = new f1.Bar()
val f2 = new Foo{}
val b2 = new f2.Bar()

f1.doNothing(b1) //fine
f1.doNothing(b2) //won't compile

- Building a type extractor

trait Inner[F] {
  type T
}

object Inner {
  def apply[F](implicit inner: Inner[F]) = inner

  implicit def mk[F[_], A] = new Inner[F[A]]{
    type T = A
  }
}

- Making it more practical

trait IsFuture[F] {
  type T

  def apply(f: F): Future[T]
}

object IsFuture {
  def apply[F](implicit isf: IsFuture[F]) = isf

  implicit def mk[A] = new IsFuture[Future[A]] {
    type T = A

    def apply(f: Future[A]): Future[A] = f
  }
}

- We can use this as an implicit guard

def logResult[Thing](thing: Thing)
  (implicit isf: IsFuture[Thing]): Future[isf.T] = 
    isf(thing) map { x =>
      log info s"I got a result of $x"
      x
    }
  						
- Here, IsFuture witnesses that the type "Thing" is a Future and allows us to convert it to it's explicit and fully qualified type.

- TAKE AWAY

- Use companion objects to hide implicit creation (apply-method) and any other boilerplate
  that might be needed to ultimately construct the dependently typed object.
- Expose the constructed type classes using an apply that returns the implicit sought.
- Dependent types can used as type parameters
- Dependent types allow us to safely cross type boundaries.

- CAPTURING MORE THAN ONE TYPE

trait Apart[F] {
  type T
  type W[X]

  def apply(f: F): W[T]
}
						
object Apart {
  def apply[F](implicit apart: Apart[F]) = apart

  implicit def mk[F[_], A] = new Apart[F[A]] {
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}

- AN ASIDE

This is more than a type constructor

type W[X]

It is an equation.

Valid declarations

trait Demo[F[_]]{
  type W[X] = F[X]
  type Ignore[X] = F[Int]
  type Identity[X] = X
  type Const[X] = Int
}
				
- TYPE REFINEMENTS

/*
trait Apart[F] {
  type T
  type W[X]

  def apply(f: F): W[T]
}
*/
object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  // type Aux[...] is just an alias to ...
  // important: and also the other way ...
  type Aux[FA, A, F[_]] = Apart[FA]{ type T = A; type W[X] = F[X] }

  implicit def mk[F[_], A]: Aux[F[A], A, F] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}
						
What does this give us?

DEPENDENT TYPES IN SCALA
SOME TIPS, TRICKS AND TECHNIQUES
@OweinReese
WHAT IS A DEPENDENT TYPE?
trait DepValue{
  type V
  val value: V
}

def magic(that: DepValue): that.V = that.value
The return type of "magic" depends on the argument passed in.
TOY EXAMPLE


def mk[T](x: T) = new DepValue{ 
  type V = T
  val value = x
}
val depInt = mk(1)
val depString = mk("two")

val itWorks: Int = magic(depInt)
val again: String = magic(depString)
						
FIRST EXAMPLE
Building a type extractor.

trait Inner[F]{
  type T
}
						

object Inner{
  def apply[F](implicit inner: Inner[F]) = inner

  implicit def mk[F[_], A] = new Inner[F[A]]{
    type T = A
  }
}
							
A MORE PRACTICAL EXAMPLE

trait IsFuture[F]{
  type T

  def apply(f: F): Future[T]
}

object IsFuture{
  def apply[F](implicit isf: IsFuture[F]) = isf

  implicit def mk[A] = new IsFuture[Future[A]]{
    type T = A

    def apply(f: Future[A]): Future[A] = f
  }
}
						
USE AS AN IMPLICIT GUARD

def logResult[Thing](thing: Thing)
  (implicit isf: IsFuture[Thing]): Future[isf.T] = 
    isf(thing) map{ x =>
      log info s"I got a result of $x"
      x
    }
  						
Here, IsFuture witnesses that the type "Thing" is a Future and allows us to convert it to it's explicit and fully qualified type.
CAPTURING MORE THAN ONE TYPE

trait Apart[F]{
  type T
  type W[X]

  def apply(f: F): W[T]
}
						

object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  implicit def mk[F[_], A] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}
							
AN ASIDE
This is more than a type constructor
type W[X]
It is an equation.
Valid declarations

trait Demo[F[_]]{
  type W[X] = F[X]
  type Ignore[X] = F[Int]
  type Identity[X] = X
  type Const[X] = Int
}
							
TYPE REFINEMENTS

object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  type Aux[FA, A, F[_]] = Apart[FA]{ type T = A; type W[X] = F[X] }

  implicit def mk[F[_], A]: Aux[F[A], A, F] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}
						
What does this give us?

- DEPENDENT TYPE CAPTURE

import scalaz._

def mapZero[Thing, F[_], A](thing: Thing)
  (implicit apart: Apart.Aux[Thing, A, F], 
                f: Functor[F], 
                m: Monoid[A]): F[A] =
    f.map(apart(thing))(_ => m.zero)

! scala-compiler can only capture/calc one type-parameter (thing),
  for 2 and more - it gives Any
! we can access [...] parames only at (implicit ...) block, there we can put a constraints on [...] parameters


- TAKE AWAY
You are not restricted to a single abstract type when using dependent types.
Type refinements can be used as a mechanism to capture the depedent types within the same implicit declaration.
Captured types do not count as a "free" type parameter.
Captured types can be used by other type classes to place constraints on types


WHAT IS A DEPENDENT TYPE?
trait DepValue{
  type V
  val value: V
}

def magic(that: DepValue): that.V = that.value
The return type of "magic" depends on the argument passed in.
FIRST EXAMPLE
Building a type extractor.

trait Inner[F]{
  type T
}
						

object Inner{
  def apply[F](implicit inner: Inner[F]) = inner

  implicit def mk[F[_], A] = new Inner[F[A]]{
    type T = A
  }
}
							
A MORE PRACTICAL EXAMPLE

trait IsFuture[F]{
  type T

  def apply(f: F): Future[T]
}

object IsFuture{
  def apply[F](implicit isf: IsFuture[F]) = isf

  implicit def mk[A] = new IsFuture[Future[A]]{
    type T = A

    def apply(f: Future[A]): Future[A] = f
  }
}
						
TYPE REFINEMENTS

object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  type Aux[FA, A, F[_]] = Apart[FA]{ type T = A; type W[X] = F[X] }

  implicit def mk[F[_], A]: Aux[F[A], A, F] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}
						
What does this give us?
DEPENDENT TYPE CAPTURE

import scalaz._

def mapZero[Thing, F[_], A](thing: Thing)
  (implicit apart: Apart.Aux[Thing, A, F], 
                f: Functor[F], 
                m: Monoid[A]): F[A] =
    f.map(apart(thing))(_ => m.zero)
							
TAKE AWAY
You are not restricted to a single abstract type when using dependent types.
Type refinements can be used as a mechanism to capture the depedent types within the same implicit declaration.
Captured types do not count as a "free" type parameter.
Captured types can be used by other type classes to place constraints on types


- TYPE LEVEL "IF" STATEMENT
ApplyEither is like a compile time "orElse."

val out = ApplyEither(1, {x: Int => 42}, {x: Double => "no"})
assert(out == 42)

val out2 = ApplyEither(2.0, {x: Int => 42}, {x: Double => "no"})
assert(out2 == "no")

The function that compiles is the function that is chosen.

- THE SET UP

object ApplyEither {
  def apply[T, F, G](t: T, f: F, g: G)
    (implicit ea: EApply[T, F, G]): ea.Out = ea(t, f, g)
}

// :ea.Out - because sometimes Scala can't infer type and ends up with Any or AnyRef or some weired type

trait EApply[T, F, G] {
  type Out

  def apply(t: T, f: F, g: G): Out
}


- DEFINE EAPPLY CREATION

object EApply extends LowPriorityEApply {
  def apply[T, F, G](implicit ea: EApply[T, F, G]) = ea

  implicit def fapply[T, R, G] = new EApply[T, T => R, G] {
      type Out = R
      def apply(t: T, f: T => R, g: G) = f(t)
  }
}
trait LowPriorityEApply {
  implicit def gapply[T, R, F] = new EApply[T, F, T => R] {
      type Out = R
      def apply(t: T, f: F, g: T => R) = g(t)
  }
}

!!! compile-time if-statement: fapply is more-priority than gapply,
using an "implicit-resolution order" rules
lineralization

- TAKE AWAY
Pattern matching on types only works if the types are mutually exclusive
Use implicit resolution order to avoid implicit ambiguity.
Don't forget to use the dependent type to help the compiler avoid "Any" or "AnyRef."


- COMPILE TIME LOOPS

Limitations on Inner and Apart?

case class Foo[V](value: V)

def zero[T, A](t: T)(implicit inner: Inner.Aux[T, A], 
                              m: Monoid[A]): inner.T = m.zero

zero(Foo(Foo(1))) //won't compile, 
// because there are no Monoid-instance for Foo[Int]
						
Neither goes deeper than the first type constructor.


- A TYPECLASS LIKE "INNER"

trait Unwrap[F]{
  type Inner
}
						
but...


- RECURSE OVER THE TYPES

object Unwrap extends LowPriorityUnwrap {
  def apply[F](implicit unwrap: Unwrap[F]) = unwrap

  type Aux[T, A] = Unwrap[T] { type Inner = A }

  implicit def nested[F[_], G](implicit unwrap: Unwrap[G]) =
    new Unwrap[F[G]]{
      type Inner = unwrap.Inner
    }
}

trait LowPriorityUnwrap {
  implicit def bottom[F[_], A] =
    new Unwrap[F[A]]{
      type Inner = A
    }
}


-- TAKE TWO

def zero[T, A](t: T)(implicit unwrap: Unwrap.Aux[T, A], 
                              m: Monoid[A]): unwrap.Inner = m.zero

val out = zero(Foo(Foo(1)))
assert(out == 0)
						
This compiles and now can access the inner type parameter of the nested Foo, Int.


FIRST EXAMPLE
Building a type extractor.

trait Inner[F]{
  type T
}
						

object Inner{
  def apply[F](implicit inner: Inner[F]) = inner

  implicit def mk[F[_], A] = new Inner[F[A]]{
    type T = A
  }
}
							
CAPTURING MORE THAN ONE TYPE

trait Apart[F]{
  type T
  type W[X]

  def apply(f: F): W[T]
}
						

object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  implicit def mk[F[_], A] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F[A]): W[T] = f
  }
}
							
AN ASIDE
This is more than a type constructor
type W[X]
It is an equation.
Valid declarations

trait Demo[F[_]]{
  type W[X] = F[X]
  type Ignore[X] = F[Int]
  type Identity[X] = X
  type Const[X] = Int
}
							
TYPE LEVEL "IF" STATEMENT
ApplyEither is like a compile time "orElse."

val out = ApplyEither(1, {x: Int => 42}, {x: Double => "no"})
assert(out == 42)

val out2 = ApplyEither(2.0, {x: Int => 42}, {x: Double => "no"})
assert(out2 == "no")
						
The function that compiles is the function that is chosen.
THE SET UP

object ApplyEither{
  def apply[T, F, G](t: T, f: F, g: G)
    (implicit ea: EApply[T, F, G]): ea.Out = ea(t, f, g)
}

trait EApply[T, F, G]{
  type Out

  def apply(t: T, f: F, g: G): Out
}
						
DEFINE EAPPLY CREATION

object EApply extends LowPriorityEApply{
  def apply[T, F, G](implicit ea: EApply[T, F, G]) = ea

  implicit def fapply[T, R, G] = new EApply[T, T => R, G] {
      type Out = R
      def apply(t: T, f: T => R, g: G) = f(t)
    }
}
trait LowPriorityEApply{
  implicit def gapply[T, R, F] = new EApply[T, F, T => R] {
      type Out = R
      def apply(t: T, f: F, g: T => R) = g(t)
    }
}
						
A TYPECLASS LIKE "INNER"

trait Unwrap[F]{
  type Inner
}
						
but...
RECURSE OVER THE TYPES

object Unwrap extends LowPriorityUnwrap{
  def apply[F](implicit unwrap: Unwrap[F]) = unwrap

  type Aux[T, A] = Unwrap[T] { type Inner = A }

  implicit def nested[F[_], G](implicit unwrap: Unwrap[G]) =
    new Unwrap[F[G]]{
      type Inner = unwrap.Inner
    }
}
trait LowPriorityUnwrap{
  implicit def bottom[F[_], A] =
    new Unwrap[F[A]]{
      type Inner = A
    }
}
						
TAKE TWO

def zero[T, A](t: T)(implicit unwrap: Unwrap.Aux[T, A], 
                              m: Monoid[A]): unwrap.Inner = m.zero

val out = zero(Foo(Foo(1)))
assert(out == 0)
						
This compiles and now can access the inner type parameter of the nested Foo, Int.


- TAKE AWAY
Dependent types can be used to pass type information around (along each step of a recursion) when solving for types.
Implicitly generated traits can be defined in terms of themselves, albeit with different type parameters.
Loops require a type structure that can be recursed over.


- DOING SOMETHING USEFUL
Let's use types to guide the behavior of our application in a more direct manner.

Who likes writing this?

def annoy[A](that: Future[List[Set[Int]]], 
                f: Int => A): Future[List[Set[A]]] =
  that map{ 
    _ map{
      _ map f
  }
}


http://wheaties.github.io/Presentations/Scala-Dep-Types/dependent-types.html#/6
6 of 7
