https://mitpress.mit.edu/books/little-typer

http://thelittletyper.com/
http://thelittletyper.com/errata.html
    38, 

http://davidchristiansen.dk/
http://davidchristiansen.dk/tutorials/
http://davidchristiansen.dk/tutorials/nbe/
https://corecursive.com/023-little-typer-and-pie-language/

Downloading repository
    https://github.com/the-little-typer/pie.git
dependencies of pie:
   todo-list
    https://github.com/david-christiansen/todo-list.git

#lang pie

2018
https://www.reddit.com/r/haskell/comments/9igdgx/the_little_typer_by_daniel_p_friedman_and_david/
2017
David Christiansen - A Little Taste of Types
    https://www.youtube.com/watch?v=3z9nISI4ppw

notes
expressions, that describe other expressions, such as Atom, are called types

A form of judgement is an observation with blank spaces in it:
1. ___ is a ___
2. ___ is the same ___ as ___
3. ___ is a type
4. ___ and ___ are the same types

Judgements are acts of knowing, and
believing is part of knowing

Some forms of judgement only make sense after an earlier judgement (pre-supposition)

The normal [form] of an expression is the most direct way of writing it
    Sameness is always according to a type

Sameness is always according to a type, so normal forms are also determined by a type

Normal forms of types:
Every expression that is a type has a normal form,
which is the most direct way of writing that type.
If two expressions are the same type,
then they have identical normal forms,
and if two types have identical normal forms,
then they are the same types
    - expr is a ___  (expr has a type of ___)

(claim one Nat)
(define one (add1 zero))

An expression with a constructor at the top is called a value
    - a value is not always normal

The c-tors of
    - Nat are "zero" and "add1"
    - Pair - "cons" 

In a value, the top constructor's arguments need not be normal
    - each expression has only one normal form


Evaluation is - finding a value that is the same as some staring exression

In Pie, everyting is an expression (even values)

! Definitions are forever !

! atoms are constructors (construct themselves),
    atoms are also values (of type Atom)

Pair, Nat and Atom - are type constructors (not a [value] constructors)

! car, however, is neigher a c-tor, nor a type c-tor
! car (and cdr) are eliminators

Constructors build values, and eliminators take apart values built by constructors

every lambda-expression is a value

! Applying a [lambda] function to arguments is the eliminator for functions

Alpha-conversion is renaming lambda-variables in a consistent way (per Alonzo Church) 

! The initial law of application:
if f is an
    (-> Y  X)
and arg is a
    Y
then (f arg) is an
    X.

! The initial first Commandment of lambda
Two lambda-expressions, that expect the same number of arguments are the same if their bodies are the same
after consistently renaming their variables (arguments)

! The initial second Commandment of lambda
if f is an (-> Y  X)
then f is the same (-> Y  X)
as
    (\ (y)
      (f y))
as long as y does not occur in f.

! The law of renaming variables
Consistently renaming variables can't change the meaning of anything.

! Neutral expressions - are not values and can not yet be evaluated due to a variable
    - (cdr x)  where x is a (Pair Nat Atom) is a neutral expression, because cdr is not a c-tor, but an elim
but
    - (cons y, 'rutabaga) is a value because by definition it has c-tor at the top

! If two expressions have identical eliminators at the top and all arguments to the eliminators are the same,
then the expressions are the same

! The Commandment of Neutral Expressions
Neutral expressions that are written identically are the same, no matter their type

! The Law and Commandment of define
Following
    (claim name X) and (define name expr)
if
    expr is an X [has type of X],
then
    name is an X [has type of X]
and
    name is the same X as expr.

! The seconce Commandment of cons
If p is a (Pair A D), then it is the same (Pair A D) as
    (cons (car p) (cdr p))

! Names in definitions
In Pie, only names that are not already used, whether for constructors, eliminators,
or previous definitions, can be used with claim or define.

Nat-eliminator:
(which-Nat target
    base
    step)

! Dim names
Unused names are written dimly, but they do need to be there

! The law or which-Nat
If target is a Nat, base is an X, and step is an
    (-> Nat
        X),
then
    (which-Nat target
        base
        step)
is an X.

! The first Commandment of which-Nat
If (which-Nat zero
    base
    step)
is an X, then it is the same X as base.

! The second Commandment of which-Nat
If (which-Nat (add1 n)
    base
    step)
is an X, then it is the same X as (step n).

! Type Values
An expression that is described by a type is a value when it has a "c-tor" at its top.
Similarly, an expression that is a type is a value when it has a "type c-tor" at its top.

Note: Type c-tors:
    Nat, Atom, Pair, ->, U

Note: The following expression is a type, but not a value
    (car (cons Atom 'prune))
    because car is neither c-tor, not a type c-tor

Judging that expr is a type requires knowing its c-tors.
But the meaning of U is not given by knowing all the type c-tors,
because new types can be introduced

! Every U Is a Type
Every expression, described by U is a type,
but not every type is described by U.

Sample:
(clame Pear
    U)
(define Pear
    (Pair Nat Nat))

Pear is not a value (names, defined with "define", are nither c-tor, nor type-c-tors)

! Definitions are unnecessary
Everything can be done without definitions, but they do improve understanding


### Recess: A Forkful of Pie

the-expressions are also referred as "type annotations"

! The law of "the"
If X is a type and e is an X, then
    (the X e)
is an X.

! The Commandment of "the"
If X is a type and e is an X, then
    (the X e)
is the same X as e.

Note: U is a type, but it does not have a type
    when expression is a type, but does not have its own type,
    Pie replies with just its normal form
Other such samples ar:
    (Pair U U), (Pair Atom U), (-> U U)


### 3: Eliminate all Natural Numbers

! Sameness
If a "same as" chart could show that two expressions are the same,
then this fact can be used anywhere without further justification.
"Same as" charts are only to help build understanding.

! Total function
A function that always assigns a value to every possible argument
is called a total function

Note: in Pie all functions are total. That's why the order of subexpressions evaluation is not important

Nat-eliminators
    - which-Nat
    - iter-Nat

! The law of iter-Nat
If target is a Nat, base is an X, and step is an
    (-> X
        X),
then
    (iter-Nat target
        base
        step)
is an X.

! The First Commandment of iter-Nat
If (iter-Nat zero
        base
        step)
is an X, then it is the same X as base.

! The Second Commandment of iter-Nat
If (iter-Nat (add1 n)
        base
        step)
is an X, then it is the same X as
    (step
        (iter-Nat n
            base
            step)).


Sample:
    (iter-Nat 5
        3
        (\ (smaller)
            (add1 smaller)))
    is 8 because it is the same as
        (add1 (add1 (add1 (add1 (add1 3)))))

(claim step-+
    (-> Nat
        Nat))
(define step-+
    (\ (+_(n-1))
        (add1 +_(n-1)))

(define +
    (\ (n j)
        (iter-Nat n
            j
            step-+)))

(define gaus
    (\ (n)
        (rec-Nat n
            0
            (\ (n-1 gaus_(n-1))
                (+ (add1 n-1) gaus_(n-1))))))


(claim step-gaus
    (-> Nat Nat
        Nat))

(define step-gaus
    (\ (n-1 gaus_(n-1))
        (+ (add1 n-1) gaus_(n-1))))

(define gaus
    (\ (n)
        (rec-Nat n
            0
            step-gaus)))


(claim *
    (-> Nat Nat
        Nat))

(claim make-step-*
    (-> Nat
        (-> Nat Nat
            Nat)))

(claim make-step-*
    (-> Nat
        (-> Nat Nat
            Nat)))

(define make-step-*
    (\ (j)
        (\ (n-1 *_(n-1))
            (+ j *_(n-1)))))

The shorter way would be

(claim step-*
    (-> Nat Nat Nat
        Nat))

(define step-*
    (\ (j n-1 *_(n-1))
        (+ j *_(n-1))))

(define *
    (\ (n j)
        (rec-Nat n
            0
            (step-* j))))

! The Law of rec-Nat
If target is a Nat, base is an X, and step is an
    (-> Nat X
        X)
then
    (rec-Nat target
        base
        step)
is an X.

! The First Commandment of rec-Nat
If
    (rec-Nat zero
        base
        step)
is an X, then it is the same X as base.

! The Second Commandment of rec-Nat
If
    (rec-Nat (add1 n)
        base
        step)
is an X, then it is the same X as
    (step n
        (rec-Nat n
            base
            step)).


### 4: Easy a Pie

(claim Pear
    U)
(define Pear
    (Pair Nat Nat))

(claim kar
    (-> (Pair Nat Nat)
        Nat))
(define kar
    (\ (p)
        (elim-Pair
            Nat Nat
            Nat
            p
            (\ (a d)
                a))))

Note: elim-Pair has not been defined yet

(claim kdr
    (-> (Pair Nat Nat)
        Nat))
(define kdr
    (\ (p)
        (elim-Pair
            Nat Nat
            Nat
            p
            (\ (a d)
                d))))

Note: elim-Pair has not been defined yet (as well as for the case of kar)


(claim swap
    (-> (Pair Nat Atom)
        (Pair Atom Nat)))
(define swap
    (\ (p)
        (elim-Pair
            Nat Atom
            (Pair Atom Nat)
            p
            (\ (a d)
                (cons d a)))))

! The Intermediate Law of Application
if f is a
    (PI ((Y U))
        X)
and Z is a U, then
    (f Z)
is an X
    where every Y has been consistently replaced by Z.


(claim elim-Pair
    (PI ((A U)
         (D U)
         (X U))
        (-> (Pair A D)
            (-> A D
                X)
            X)))
(define elim-Pair
    (\ (A D X)
        (\ (p f)
            (f (car p) (cdr p)))))

(define kar
    (\ (p)
        (elim-Pair
            Nat Nat
            Nat
            p
            (\ (a d)
                a))))
(define kdr
    (\ (p)
        (elim-Pair
            Nat Nat
            Nat
            p
            (\ (a d)
                d))))
(define swap
    (\ (p)
        (elim-Pair
            Nat Atom
            (Pair Atom Nat)
            p
            (\ (a d)
                (cons d a)))))

To be a
    (PI ((Y U))
        X)
is to be a lambda-expression that, when applied to a type T,
results in an expression with the type that is a result of
consistently replacing every Y in X with T.

(claim twin
    (PI ((Y U))
        (-> Y
            (Pair Y Y))))
(define twin
    (\ (Y)
        (\ (x)
            (cons x x))))

(claim twin-Atom
    (-> Atom
        (Pair Atom Atom)))
(define twin-Atom
    (twin Atom))


### 5: Lists, Lists and more Lists

(claim expectations
    (List Atom))
(define expressions
    (:: 'cooked
        (:: 'eaten
            (:: 'tried-cleaning
                (:: 'understood
                    (:: 'slept nil))))))

! The Law of List
If E is a type, then (List E) is a type.

nil - is a c-tor
::  - is another c-tor

! The Law of nil
nil is a (List E), no matter what type E is.

! The Law of ::
If e is an E and es is a (List E),
then (:: e es) is a (List E).

! The Law of rec-List
If target is a (List E), base is an X, and step is an
    (-> E (List E)  X
        X)
then
    (rec-List target
        base
        step)
is an X.

! The First Commandment of rec-List
If (rec-List nil
        base
        step)
is an X, then it is the same X as base.

! The Second Commandment of rec-List
If (rec-List (:: e es)
        base
        step)
is an X, then it is the same X as an
    (step e es
        (rec-List es
            base
            step)).

(claim length
    (PI ((E U))
        (-> (List E)
            Nat)))
(claim step-length
    (PI ((E U))
        (-> E (List E) Nat
            Nat)))

(define step-length
    (\ (E)
        (\ (e es length_es)
            (add1 length_es))))
(define length
    (\ (E)
        (\ (es)
            (rec-List es
                (step-length E)))))

Narrowing this down to concrete types (of E) gieves us

(claim length-Atom
    (-> (List Atom)
        Nat))
(define length-Atom
    (length Atom))

! List Entry Types
All the entries in a list must have the same type

(claim append
    (PI ((E U))
        (-> (List E) (List E)
            (List E))))
(claim step-append
    (PI ((E U))
        (-> E (List E) (List E)
            (List E))))

(define step-append
    (\ (E)
        (\ (e es append_es)
            (:: e append_es))))
(define append
    (\ (E)
        (\ (start end)
            (rec-List start
                end
                (step-append E)))))

(claim snoc
    (PI ((E U))
        (-> (List E) E
            (List E))))
(define snoc
    (\ (E)
        (\ (start e)
            (rec-List start
                (:: e nil)
                (step-append E)))))

(claim concat
    (PI ((E U))
        (-> (List E) (List E)
            (List E))))
(claim step-concat
    (PI ((E U))
        (-> E (List E) (List E)
            (List E))))

(define step-concat
    (\ (E)
        (\ (e es concat_es)
            (snoc E concat_es e))))
(define concat
    (\ (E)
        (\ (start end)
            (rec-List end
                start
                (step-concat E)))))

(claim reverse
    (PI ((E U))
        (-> (List E)
            (List E))))
(define reverse
    (\ (E)
        (\ (es)
            (rec-List es
                nil
                (step-reverse E)))))


### 6. Precisely How Many?

! The Law of Vec
