https://mitpress.mit.edu/books/little-typer

http://thelittletyper.com/
http://thelittletyper.com/errata.html
    38, 

http://davidchristiansen.dk/
http://davidchristiansen.dk/tutorials/
http://davidchristiansen.dk/tutorials/nbe/
https://corecursive.com/023-little-typer-and-pie-language/

Downloading repository
    https://github.com/the-little-typer/pie.git
dependencies of pie:
   todo-list
    https://github.com/david-christiansen/todo-list.git

#lang pie

2018
https://www.reddit.com/r/haskell/comments/9igdgx/the_little_typer_by_daniel_p_friedman_and_david/
2017
David Christiansen - A Little Taste of Types
    https://www.youtube.com/watch?v=3z9nISI4ppw

notes
expressions, that describe other expressions, such as Atom, are called types

A form of judgement is an observation with blank spaces in it:
1. ___ is a ___
2. ___ is the same ___ as ___
3. ___ is a type
4. ___ and ___ are the same types

Judgements are acts of knowing, and
believing is part of knowing

Some forms of judgement only make sense after an earlier judgement (pre-supposition)

The normal [form] of an expression is the most direct way of writing it
    Sameness is always according to a type

Sameness is always according to a type, so normal forms are also determined by a type

Normal forms of types:
Every expression that is a type has a normal form,
which is the most direct way of writing that type.
If two expressions are the same type,
then they have identical normal forms,
and if two types have identical normal forms,
then they are the same types
    - expr is a ___  (expr has a type of ___)

(claim one Nat)
(define one (add1 zero))

An expression with a constructor at the top is called a value
    - a value is not always normal

The c-tors of
    - Nat are "zero" and "add1"
    - Pair - "cons" 

In a value, the top constructor's arguments need not be normal
    - each expression has only one normal form


Evaluation is - finding a value that is the same as some staring exression

In Pie, everyting is an expression (even values)

! Definitions are forever !

! atoms are constructors (construct themselves),
    atoms are also values (of type Atom)

Pair, Nat and Atom - are type constructors (not a [value] constructors)

! car, however, is neigher a c-tor, nor a type c-tor
! car (and cdr) are eliminators

Constructors build values, and eliminators take apart values built by constructors

every lambda-expression is a value

! Applying a [lambda] function to arguments is the eliminator for functions

Alpha-conversion is renaming lambda-variables in a consistent way (per Alonzo Church) 

! The initial law of application:
if f is an
    (-> Y  X)
and arg is a
    Y
then (f arg) is an
    X.

! The initial first Commandment of lambda
Two lambda-expressions, that expect the same number of arguments are the same if their bodies are the same
after consistently renaming their variables (arguments)

! The initial second Commandment of lambda
if f is an (-> Y  X)
then f is the same (-> Y  X)
as
    (\ (y)
      (f y))
as long as y does not occur in f.

! The law of renaming variables
Consistently renaming variables can't change the meaning of anything.

! Neutral expressions - are not values and can not yet be evaluated due to a variable
    - (cdr x)  where x is a (Pair Nat Atom) is a neutral expression, because cdr is not a c-tor, but an elim
but
    - (cons y, 'rutabaga) is a value because by definition it has c-tor at the top

! If two expressions have identical eliminators at the top and all arguments to the eliminators are the same,
then the expressions are the same

! The Commandment of Neutral Expressions
Neutral expressions that are written identically are the same, no matter their type

! The Law and Commandment of define
Following
    (claim name X) and (define name expr)
if
    expr is an X [has type of X],
then
    name is an X [has type of X]
and
    name is the same X as expr.

! The seconce Commandment of cons
If p is a (Pair A D), then it is the same (Pair A D) as
    (cons (car p) (cdr p))

! Names in definitions
In Pie, only names that are not already used, whether for constructors, eliminators,
or previous definitions, can be used with claim or define.

