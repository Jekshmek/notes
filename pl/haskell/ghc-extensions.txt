https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions
https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions

ViewPatterns:
http://www.reddit.com/r/haskell/comments/2o341e/24_days_of_ghc_extensions_view_patterns/
https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html

PatternSynonyms:
http://www.reddit.com/r/haskell/comments/2o6bq5/24_days_of_ghc_extensions_pattern_synonyms/
https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html

Record

Deriving:
http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
http://www.haskell.org/haskellwiki/GHC.Generics

StandaloneDeriving   - derive type classes without modifying sources
                       deriving instance Show <MyData>
DeriveGeneric        - derive instances of the class Generic, defined in GHC.Generics.
                       define generic functions, as described in Section 7.20, “Generic programming”.
DeriveFunctor        - derive instances of the class Functor, defined in GHC.Base. 
DeriveFoldable       - derive instances of the class Foldable, defined in Data.Foldable. 
DeriveTraversable    - derive instances of the class Traversable, defined in Data.Traversable.



TypeSynonymInstances - removes the restriction to write an instance of a typeclass for a specialized version of a
                       polymorphic type
OverlappingInstances - When there are multiple overlapping instances to choose from, this extension causes the compiler to 
                       pick the most specific one

RecordWildcards:
Record wildcard syntax permits a ".." in a record pattern, where each elided field f is replaced by the pattern f = f.
http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards

http://www.reddit.com/r/haskell/comments/2oaj7e/24_days_of_ghc_extensions_record_wildcards/
https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html

BangPatterns:
http://www.reddit.com/r/haskell/comments/2oe1kk/24_days_of_ghc_extensions_bang_patterns/
https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html

RebindableSyntax:
http://www.reddit.com/r/haskell/comments/2ohm6p/24_days_of_ghc_extensions_rebindable_syntax_guest/
https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html

ListComprehensions:
http://www.reddit.com/r/haskell/comments/2okwpo/24_days_of_ghc_extensions_list_comprehensions/
https://ocharles.org.uk/blog/guest-posts/2014-12-07-list-comprehensions.html

TypeOperators:
http://www.reddit.com/r/haskell/comments/2oo1z7/24_days_of_ghc_extensions_type_operators/
https://ocharles.org.uk/blog/posts/2014-12-08-type-operators.html

RecursiveDo:
http://www.reddit.com/r/haskell/comments/2osh3v/24_days_of_ghc_extensions_recursive_do/
https://ocharles.org.uk/blog/posts/2014-12-09-recursive-do.html

NullaryTypeclasses:
http://www.reddit.com/r/haskell/comments/2ovvnk/24_days_of_ghc_extensions_nullary_type_classes/
https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html

ImplicitParameters:
http://www.reddit.com/r/haskell/comments/2p0b3j/24_days_of_ghc_extensions_implicit_parameters/
https://ocharles.org.uk/blog/posts/2014-12-11-implicit-params.html

DoAndIfThenElse      - https://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
                       ??? check if it is on by default ???


ConstraintKinds:
http://www.reddit.com/r/haskell/comments/2jg4y5/hiding_liftio/

That's the reason why recently started to write code like this:

foo :: (Applicative m, Functor m, MonadState Foo m, MonadReader Bar m, MonadIO m, etc.) => m ()

With ConstraintKinds I can even use a convenient type alias for this:

type App m = (Applicative m, Functor m, MonadState Foo m, MonadReader Bar m, MonadIO m, etc.)
foo :: App m => m ()

However, I'm wondering if this is idiomatic. Or if there are any downsides.

