https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions
https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions

ViewPatterns:
http://www.reddit.com/r/haskell/comments/2o341e/24_days_of_ghc_extensions_view_patterns/
https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html

PatternSynonyms:
http://www.reddit.com/r/haskell/comments/2o6bq5/24_days_of_ghc_extensions_pattern_synonyms/
https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html

Deriving:
http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
http://www.haskell.org/haskellwiki/GHC.Generics

StandaloneDeriving   - derive type classes without modifying sources
                       deriving instance Show <MyData>
DeriveGeneric        - derive instances of the class Generic, defined in GHC.Generics.
                       define generic functions, as described in Section 7.20, “Generic programming”.
DeriveFunctor        - derive instances of the class Functor, defined in GHC.Base. 
DeriveFoldable       - derive instances of the class Foldable, defined in Data.Foldable. 
DeriveTraversable    - derive instances of the class Traversable, defined in Data.Traversable.



TypeSynonymInstances - removes the restriction to write an instance of a typeclass for a specialized version of a
                       polymorphic type
OverlappingInstances - When there are multiple overlapping instances to choose from, this extension causes the compiler to 
                       pick the most specific one
RecordWildcards      - http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
                       Record wildcard syntax permits a ".." in a record pattern, where each elided field f is replaced by the pattern f = f.
DoAndIfThenElse      - https://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
                       ??? check if it is on by default ???


ConstraintKinds:
http://www.reddit.com/r/haskell/comments/2jg4y5/hiding_liftio/

That's the reason why recently started to write code like this:

foo :: (Applicative m, Functor m, MonadState Foo m, MonadReader Bar m, MonadIO m, etc.) => m ()

With ConstraintKinds I can even use a convenient type alias for this:

type App m = (Applicative m, Functor m, MonadState Foo m, MonadReader Bar m, MonadIO m, etc.)
foo :: App m => m ()

However, I'm wondering if this is idiomatic. Or if there are any downsides.

