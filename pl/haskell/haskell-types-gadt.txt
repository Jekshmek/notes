Eisenberg - LambdaConf 2015 - A Practical Introduction to Haskel GADTs
https://github.com/goldfirere/glambda

{- *** 1 *** -}

{-# LANGUAGE GADTs #-}

{- data Maybe a = Nothing | Just a -}

{- in plain ADTs the 2 c-tors just return a "Maybe a" -}

data STy ty where
  SInt  :: STy Int
  SBool :: STy Bool

{- In GADTs we return either "STy Int" or "STy Bool" -}

zero :: STy ty -> ty
zero SInt = 0
zero SBool = False

{- STy is actually a singleton-type.
   If we have "STy Int", the only possible value we can give is SInt

   STy is an indexed-type (it uses a parameter)
-}


{- *** 2 *** -}

data STy ty where
  SInt   :: STy Int
  SBool  :: STy Bool
  SMaybe :: STy ty' -> STy (Maybe ty')


zero :: STy ty -> ty
zero SInt       = 0
zero SBool      = False
zero (SMaybe _) = Nothing

{- when we pattern-match, we learn about the types -}


{- *** 3 *** -}

data STy ty
  = (ty ~ Int)  => SInt
  | (ty ~ Bool) => SBool
  | forall ty'. (ty ~ Maybe ty') => SMaybe (STy ty')

zero :: STy ty -> ty
zero SInt       = 0
zero SBool      = False
zero (SMaybe _) = Nothing

{-
    a little-more traditional syntax
    (~) - is a type equality

    SMaybe is called an existential data c-tor, package up a ty'
-}

{- !!! pattern-matching a term reveals type information
   (gives type-level information)
-}

----
{-# LANGUAGE GADTs, StandaloneDeriving #-}
deriving instance Show (STy ty)
!!! if you encounter untouchabe bla-bla error, just add direct type signature
----


{- *** ScopedTypeVariables *** -}

foo :: a -> ...
foo x = ...
  where fhelper :: a
        fhelper = ...

bar :: forall a. a -> ...
bar x = ...
  where bhelper :: a
        bhelper = ...

{-
  Strange, but: in the body of foo, fhelper and x have different types
                in the body of bar, bhelper and x have the same  types
  !!! add ScopedTypeVariables ext !!!
-}
{-
    GHC bug #3927: Pattern warnings + GADTs = Inadequate
-}


{- *** 4 *** -}

data STy ty where
  SInt   :: STy Int
  SBool  :: STy Bool
  SMaybe :: STy ty' -> STy (Maybe ty')

zero :: STy ty -> ty
zero SInt       = 0
zero SBool      = False
zero (SMaybe _) = Nothing

eqSTy :: STy ty -> STy ty -> Bool
eqSTy SInt SInt = true
eqSTy SBool SBool = true
{- pattern-matching non-ex... if we en-up right here -}
eqSTy (SMaybe a) (SMaybe b) = a `eqSTy` b
{- bogus warning about missing clauses, have appropriate GHC bug #3927 -}

{- *** HList *** -}
{- *** 4 *** -}

{-# LANGUAGE GADTs, TypeOperators, DataKinds, PolyKinds #-}

module HList where

data HList tys where
  Nil  :: HList '[]
  (:>) :: h -> HList t -> HList (h ': t)
infixr 5 :>

{- tys - the whole list of types
  HList '[]
    -- this Nil - is a data c-tor, which creates an HList with a list of types of the elements is empty
  HList (h ': t)
    -- ...

  :t (True :> () :> [Just 'x'] :> "hi" :> Nil)
  :: HList '[Bool, (), [Maybe Char], [Char]]
-}
