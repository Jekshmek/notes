Paumard - Java 8 Streams and Collectors Patterns
http://www.slideshare.net/jpaumard/java-8-streams-collectors-patterns-performances-and-parallelization

Presentations:
Valeev - JPoing 2016


Goetz:
http://www.ibm.com/developerworks/java/library/j-java-streams-1-brian-goetz/index.html
http://www.ibm.com/developerworks/java/library/j-java-streams-2-brian-goetz/index.html
http://www.ibm.com/developerworks/java/library/j-java-streams-3-brian-goetz/index.html

Characteristics:
SIZED
SUBSIZED
SORTED
ORDERED
DISTINCT
NONNULL
IMMUTABLE
CONCURRENT

characterized by Spliterator
.trySplit()

.boxed()
    ???

.sorted()
    full-barier operation (downstream ops can't start until this one ends)
.skip() and .limit()
    does not preserve the stream size :(
    .sublis() - is more effective
    .parallell() stream really utilize Spliterator and do a HUGE perf-boost
.distinct()
    .parallell().unordered() - can speed-up according to doc-n, but 10x slower than parallell and 3x to seq-l
    .parallell.ordered and .parallell.unordered a just 2 distinct algos
.concat()
    ??? temporary or terminal
    preserves SIZED if parts are SIZED
.flatMap()
    like concat but better with ORDERED streams than .concat()
