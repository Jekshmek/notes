https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-language-ref

packages
org.springframework.expression 
org.springframework.expression.spel.support

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression("'Hello World'");
String message = (String) exp.getValue();

Expression exp = parser.parseExpression("'Hello World'.bytes");
// invokes 'getBytes()'
byte[] bytes = (byte[]) exp.getValue();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression("'Hello World'.bytes.length");
int length = (Integer) exp.getValue();

// call String c-tor
Expression exp = parser.parseExpression("new String('hello world').toUpperCase()");
String message = exp.getValue(String.class);

Note the use of the generic method public <T> T getValue(Class<T> desiredResultType).
Using this method removes the need to cast the value of the expression to the desired result type.
An EvaluationException will be thrown if the value cannot be cast to the type T or converted using the registered type converter.

The more common usage of SpEL is to provide an expression string that is evaluated against a specific object instance (called the root object).
There are two options here and which to choose depends on whether the object against which the expression is being evaluated
will be changing with each call to evaluate the expression.

In the following example we retrieve the name property from an instance of the Inventor class.

// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("name");

EvaluationContext context = new StandardEvaluationContext(tesla);
String name = (String) exp.getValue(context);


The class StandardEvaluationContext is where you can specify which object the "name" property will be evaluated against.
This is the mechanism to use if the root object is unlikely to change, it can simply be set once in the evaluation context.
If the root object is likely to change repeatedly, it can be supplied on each call to getValue, as this next example shows:

// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("name");
String name = (String) exp.getValue(tesla);

In this case the inventor tesla has been supplied directly to getValue and the expression evaluation infrastructure creates and manages
a default evaluation context internally - it did not require one to be supplied.


Expression exp = parser.parseExpression("name == 'Nikola Tesla'");
boolean result = exp.getValue(context, Boolean.class); // evaluates to true


The EvaluationContext interface
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-evaluation-context

The out-of-the-box implementation, StandardEvaluationContext, uses reflection to manipulate the object,
caching java.lang.reflect.Method, java.lang.reflect.Field, and java.lang.reflect.Constructor instances for increased performance

The StandardEvaluationContext is where you may specify the root object to evaluate against via the method setRootObject()
or passing the root object into the constructor.
You can also specify variables and functions that will be used in the expression using the methods setVariable() and registerFunction(). 
The use of variables and functions are described in the language reference sections Variables and Functions.
The StandardEvaluationContext is also where you can register custom ConstructorResolvers, MethodResolvers, and PropertyAccessors
to extend how SpEL evaluates expressions.

ype conversion

By default SpEL uses the conversion service available in Spring core ( org.springframework.core.convert.ConversionService).
This conversion service comes with many converters built in for common conversions but is also fully extensible
so custom conversions between types can be added.
Additionally it has the key capability that it is generics aware.
This means that when working with generic types in expressions, SpEL will attempt conversions to maintain type correctness for any objects it encounters.



What does this mean in practice? Suppose assignment, using setValue(), is being used to set a List property.
The type of the property is actually List<Boolean>.
SpEL will recognize that the elements of the list need to be converted to Boolean before being placed in it.

A simple example:

class Simple {
    public List<Boolean> booleanList = new ArrayList<Boolean>();
}

Simple simple = new Simple();

simple.booleanList.add(true);

StandardEvaluationContext simpleContext = new StandardEvaluationContext(simple);

// false is passed in here as a string. SpEL and the conversion service will
// correctly recognize that it needs to be a Boolean and convert it
parser.parseExpression("booleanList[0]").setValue(simpleContext, "false");

// b will be false
Boolean b = simple.booleanList.get(0);

Predefined stuff
* systemProperties

Annotation config
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-beandef-annotation-based

@Value - on fields, methods, method/c-tor params to specify a default value

Reference
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-language-ref

Literal
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-ref-literal

The types of literal expressions supported are strings, numeric values (int, real, hex), boolean and null.
Strings are delimited by single quotes. To put a single quote itself in a string, use two single quote characters.
