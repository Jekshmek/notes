Why:
    ServiceLocator
    PropertiesLocator
    Injection


Application model:

public class FirstService
    @Autowired
    public Singleton singleton;
    @Autowired
    public Prototype prototype;
}

public class SecondService
    @Autowired
    public Singleton singleton;
    @Autowired
    public Prototype prototype;
}

public class Singleton {
}

public class Prototype {
}

public class FactoryBean  {
}

public class Factory {
    public static FactoryBean factoryMethod() {
        return new FactoryBean();
    }
}

xml-config
    <context:annotation-config/>
    <bean id="firstService" class="..."/> // constructor-arg
    <bean id="secondService" class="..."/>
    <bean id="singleton" class="..."/>
    <bean id="prototype" class="..."
        scope="prototype"/>
    <bean id="factoryBean" class="..."
        factory-method="factoryMethod"/>

AppCtx-s:
ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config-10.xml");

FirstService firstService = ctx.getBean(FirstService.class);


annotation-config:

@Component("mixedBean")
public class MixedConfigurationBean {
    public int value;

    public MixedConfigurationBean() {
    }

    public MixedConfigurationBean(int value) {
        this.value = value;
    }
}

<context:component-scan
    base-package="...beans.mixed"/>
    
<bean id="mixedBean"
    class="...beans.mixed.MixedConfigurationBean">
    <constructor-arg type="int" value="1"/>
</bean>

In this case - XML-config wins. Flawless victory
INFO: Overriding bean definition for bean 'mixedBean' with a different definition:
1

java-config:

@Configuration
public class ScopesConfig11 {
    @Bean
    public FirstService firstService() {
        return new FirstService();
    }
    @Bean
    public SecondService secondService() {
        return new SecondService();
    }
    @Bean
    public Singleton singleton() {
        return new Singleton();
    }
    @Bean
    @Scope(BeanDefinition.SCOPE_PROTOTYPE)
    public Prototype prototype() {
        return new Prototype();
    }
}

ApplicationContext ctx = new AnnotationConfigApplicationContext(ScopesConfig11.class);
...


Lookup 1 (dirty)

@Autowired
private ApplicationContext ctx;

private UserAction getUserAction(String email) {
    UserAction result = ctx.getBean(UserAction.class);
    result.email = email;
    return result;
}

Lookup 2

private UserAction getUserAction(String email) {
    UserAction result = buildUserAction();
    result.email = email;
    return result;
}

public UserAction buildUserAction() { return null; }

<bean id="userService" class="...beans.userservice.UserService">
    <lookup-method name="buildUserAction" bean="userAction/>
<bean>

<bean id="userAction" class="...beans.userservice.UserAction" scope="prototype" />

Lookup (java-config)

... getUserAction ...
@Lookup
public UserAction buildUserAction() { return null }

@Config
// !!! lookup methods cannot get replaced on beans, returned from factory methods where we cannot dynamically provide a sublass for them
@ComponentScan("...beans.userservice")
public class ScopesConfig21 {
    @Bean
    public UserService userService() {
        return new UserService();
    }
    @Bean
    @Scope(BeanDefinition.SCOPE_PROTOTYPE)
    public UserAction userAction() {
        return new UserAction();
    }
}

...
@Component
public class UserService {
    ...
}
