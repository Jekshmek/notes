Simple Query:

curl -XGET 'localhost:9200/library/book/_search?pretty=true' -d '{
 "query" : {
  "term" : { "title" : "crime" }
 }
}'

resp:
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 0.19178301,
    "hits" : [ {
      "_index" : "library",
      "_type" : "book",
      "_id" : "4",
      "_score" : 0.19178301, "_source" : { "title": "Crime and Punishment","otitle": "????????é??? ? ?????á???","author": "Fyodor Dostoevsky","year": 1886,"characters": ["Raskolnikov", "Sofia Semyonovna Marmeladova"],"tags": [],"copies": 0, "available" : true}
    } ]
  }
}

Let's sum up the possible call types and see what the addressing looks like:
1. Request to index and type:
    curl -XGET 'localhost:9200/library/book/_search' -d @query.json

2. Request to index and all types in it:
    curl -XGET 'localhost:9200/library/_search' -d @query.json

3. Request to all indices:
    curl -XGET 'localhost:9200/_search' -d @query.json

4. Request to few indices:
    curl -XGET 'localhost:9200/library,bookstore/_search' -d @query.json
    
5. Request to multiple indices and multiple types in them:
    curl -XGET 'localhost:9200/library,bookstore/book,recipes/_search' -d @query.json


Paging and result size:

{
 "from" :  9,
 "size" : 20,
 "query" : {
  "term" : { "title" : "crime" }
 }
}

Version:
...
 "version" : true,
...
resp:
...
 "version" : 1
...

Limiting the score:
...
 "min_score" : 0.75,
...

Choosing the fields we want to return:
...
 "fields" : [ "title", "year" ],
...
resp:
...
 "fields" : {
   "title" : "..."
   "year" : 1886
 }
...
Note: ES can return stored fields only or if the "_source" field is used
  "*" - if we need all the stored fields.
  "include" : [ "prefix*" ] - if we need partial fields.
  "exclude" : [ ...]


Query types - Basic queries:

Term query:

{
 "query" : {
  "term" : {
   "title" : {
    "value" : "crime",
    "boost" : 10.0
   }
  }
 }
}

Note: the term query is not analyzed, so you need to provide the exact term that will match the term in the indexed document.
However, you can also include the boost attribute in your term query; this will affect the importance of the given term.

The terms query

{
 "query" : {
  "terms" : {
   "tags" : [ "novel", "book" ]
   "minimum_match" : 1
  }
 }
}

The match query

{
 "query" : {
  "match" : {
   "title" : "crime and punishment"
  }
 }
}

It takes the values given in the query parameter, analyzes them, and constructs the appropriate query out of them.
When using a match query, ElasticSearch will choose the proper analyzer for a field we've chosen,
so you can be sure that the terms passed to the match query will be processed by the same analyzer that was used during indexing.

Please remember that the match query (and as further explained, the multi match query) doesn't support Lucene query syntax


The Boolean match query

is a query that analyzes the provided text and makes a Boolean query out of it.

There are a few parameters that allow us to control the behavior of Boolean match queries:
operator:
    This can take the value of or or and and control what Boolean operator is used to connect the created Boolean clauses.
    The default value is or.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
fuzziness:
    Providing the value of this parameter allows one to construct fuzzy queries.
    It should take values from 0.0 to 1.0 for a string object.
    While constructing fuzzy queries, this parameter will be used to set the similarity.
prefix_length:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section below.
max_expansions:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section in below.
The parameters should be wrapped in the name of the field we are running the query against.
So, if we wanted to run a sample Boolean match query against the title field, we could send a query like so:

{
 "query" : {
  "match" : {
   "title" : {
    "query" : "crime and punishment",
    "operator" : "and"
   }
  }
 }
}


The phrase match query

Similar to the Boolean query, but instead of constructing the Boolean clauses from the analyzed text, it constructs a phrase query.

The following parameters are available:
slop:
    This is an integer value that defines how many unknown words can be put between terms in the text query for a match to be considered a phrase.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
    
A sample phrase match query against the title field could look like the following code:
{
 "query" : {
  "match_phrase" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1
   }
  }
 }
}


The match phrase prefix query

The last type of the match query is the match phrase prefix query.
This query is almost the same as the prefix match query, but in addition, it allows prefix matches on the last term in the query text.
Also, in addition to the parameters exposed by the match phrase query, it exposes an additional one, the max_expansions parameter,
which controls how many prefixes the last terms will be rewritten to.

Our sample query changed to the match phrase prefix query could look like this:
{
 "query" : {
  "match_phrase_prefix" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1,
    "max_expansions" : 20
   }
  }
 }
}


The multi match query

This is the same as the match query, but instead of running against a single field, it can be run against multiple fields with the use of the fields parameter.
Of course, all the parameters you use with the match query can be used with the multi match query.
So, if we want to modify our match query to be run against the title and otitle fields, we could run the following query:
{
 "query" : {
  "multi_match" : {
   "query" : "crime punishment",
   "fields" : [ "title", "otitle" ]
  }
 }
}


