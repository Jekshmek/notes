Simple Query:

curl -XGET 'localhost:9200/library/book/_search?pretty=true' -d '{
 "query" : {
  "term" : { "title" : "crime" }
 }
}'

resp:
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 0.19178301,
    "hits" : [ {
      "_index" : "library",
      "_type" : "book",
      "_id" : "4",
      "_score" : 0.19178301, "_source" : { "title": "Crime and Punishment","otitle": "????????é??? ? ?????á???","author": "Fyodor Dostoevsky","year": 1886,"characters": ["Raskolnikov", "Sofia Semyonovna Marmeladova"],"tags": [],"copies": 0, "available" : true}
    } ]
  }
}

Let's sum up the possible call types and see what the addressing looks like:
1. Request to index and type:
    curl -XGET 'localhost:9200/library/book/_search' -d @query.json

2. Request to index and all types in it:
    curl -XGET 'localhost:9200/library/_search' -d @query.json

3. Request to all indices:
    curl -XGET 'localhost:9200/_search' -d @query.json

4. Request to few indices:
    curl -XGET 'localhost:9200/library,bookstore/_search' -d @query.json
    
5. Request to multiple indices and multiple types in them:
    curl -XGET 'localhost:9200/library,bookstore/book,recipes/_search' -d @query.json


Paging and result size:

{
 "from" :  9,
 "size" : 20,
 "query" : {
  "term" : { "title" : "crime" }
 }
}

Version:
...
 "version" : true,
...
resp:
...
 "version" : 1
...

Limiting the score:
...
 "min_score" : 0.75,
...

Choosing the fields we want to return:
...
 "fields" : [ "title", "year" ],
...
resp:
...
 "fields" : {
   "title" : "..."
   "year" : 1886
 }
...
Note: ES can return stored fields only or if the "_source" field is used
  "*" - if we need all the stored fields.
  "include" : [ "prefix*" ] - if we need partial fields.
  "exclude" : [ ...]


Query types - Basic queries:

Term query:

{
 "query" : {
  "term" : {
   "title" : {
    "value" : "crime",
    "boost" : 10.0
   }
  }
 }
}

Note: the term query is not analyzed, so you need to provide the exact term that will match the term in the indexed document.
However, you can also include the boost attribute in your term query; this will affect the importance of the given term.

The terms query

{
 "query" : {
  "terms" : {
   "tags" : [ "novel", "book" ]
   "minimum_match" : 1
  }
 }
}

The match query

{
 "query" : {
  "match" : {
   "title" : "crime and punishment"
  }
 }
}

It takes the values given in the query parameter, analyzes them, and constructs the appropriate query out of them.
When using a match query, ElasticSearch will choose the proper analyzer for a field we've chosen,
so you can be sure that the terms passed to the match query will be processed by the same analyzer that was used during indexing.

Please remember that the match query (and as further explained, the multi match query) doesn't support Lucene query syntax


The Boolean match query

is a query that analyzes the provided text and makes a Boolean query out of it.

There are a few parameters that allow us to control the behavior of Boolean match queries:
operator:
    This can take the value of or or and and control what Boolean operator is used to connect the created Boolean clauses.
    The default value is or.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
fuzziness:
    Providing the value of this parameter allows one to construct fuzzy queries.
    It should take values from 0.0 to 1.0 for a string object.
    While constructing fuzzy queries, this parameter will be used to set the similarity.
prefix_length:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section below.
max_expansions:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section in below.
The parameters should be wrapped in the name of the field we are running the query against.
So, if we wanted to run a sample Boolean match query against the title field, we could send a query like so:

{
 "query" : {
  "match" : {
   "title" : {
    "query" : "crime and punishment",
    "operator" : "and"
   }
  }
 }
}


The phrase match query

Similar to the Boolean query, but instead of constructing the Boolean clauses from the analyzed text, it constructs a phrase query.

The following parameters are available:
slop:
    This is an integer value that defines how many unknown words can be put between terms in the text query for a match to be considered a phrase.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
    
A sample phrase match query against the title field could look like the following code:
{
 "query" : {
  "match_phrase" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1
   }
  }
 }
}


The match phrase prefix query

The last type of the match query is the match phrase prefix query.
This query is almost the same as the prefix match query, but in addition, it allows prefix matches on the last term in the query text.
Also, in addition to the parameters exposed by the match phrase query, it exposes an additional one, the max_expansions parameter,
which controls how many prefixes the last terms will be rewritten to.

Our sample query changed to the match phrase prefix query could look like this:
{
 "query" : {
  "match_phrase_prefix" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1,
    "max_expansions" : 20
   }
  }
 }
}


The multi match query

This is the same as the match query, but instead of running against a single field, it can be run against multiple fields with the use of the fields parameter.
Of course, all the parameters you use with the match query can be used with the multi match query.
So, if we want to modify our match query to be run against the title and otitle fields, we could run the following query:
{
 "query" : {
  "multi_match" : {
   "query" : "crime punishment",
   "fields" : [ "title", "otitle" ]
  }
 }
}


The query string query

In comparison with the other queries available, the query string query supports full Apache Lucene query syntax,
so it uses a query parser to construct an actual query using the provided text. A sample query string query can look like this:
{
 "query" : {
  "query_string" : {
   "query" : "title:crime^10 +title:punishment -otitle:cat +author:(+Fyodor +dostoevsky)",
   "default_field" : "title"
  }
 }
}

You may wonder what that weird syntax in the query parameter is; we will get to it in the Lucene query syntax part of the query string query description.
As with most of the queries in ElasticSearch, the query string query provides a few parameters that allow us to control query behavior:

query:
    This specifies the query text
default_field:
    This specifies the default field the query will be executed against.
    It defaults to the "index.query.default_field property", which is by default set to "_all".
default_operator:
    This specifies the default logical operator (or/and) used when no operator is specified.
    The default value of this parameter is "or".
analyzer:
    This specifies the name of the analyzer used to analyze the query provided in the "query" parameter.
allow_leading_wildcard:
    This specifies whether a wildcard allowed as the first character of a term;
    it defaults to true.
lowercase_expand_terms:
    This specifies whether terms rewritten by the query are lowercased.
    It defaults to true.
enable_position_increments:
    This specifies whether position increments are turned on in the result query.
    It defaults to true.
fuzzy_prefix_length:
    This is the prefix length for generated fuzzy queries, and it defaults to 0.
    To learn more about it, please look at the The fuzzy query section.
fizzy_min_sim:
    This specifies the minimum similarity for fuzzy queries and defaults to 0.5.
    To learn more about it, please look at the The fuzzy query section.
phrase_slop:
    This specifies the phrase slop and defaults to 0.
    To learn more about it, please look at the The phrase match query section.
boost:
    This is the boost value used and defaults to 1.0.
analyze_wildcard:
    This specifies whether the wildcard characters should be analyzed.
    It defaults to true.
auto_generate_phrase_queries:
    This specifies whether phrase queries should be automatically generated.
    It defaults to false.
minimum_should_match:
    This controls how many of the generated Boolean clauses should match to consider a hit for a given document.
    The value should be provided as a percentage, for example 50%, which would mean that at least 50 percent of the given terms should match.
lenient:
    This parameter can take the value of true or false.
    If it is set to true, format-based failures will be ignored.

Please note that the query string query can be rewritten by ElasticSearch, and because of that, ElasticSearch allows us to pass additional parameters that control the rewrite method.
However, for more details about that process, see the Query rewrite section later.


DisMax:

In order to use the DisMax query, one should add the use_dis_max property set to true:

{
 "query" : {
  "query_string" : {
   "query" : "crime punishment",
   "fields" : [ "title", "otitle" ],
   "use_dis_max" : true
  }
 }
}


The Field query

Is the simplified version of the query string query:

{
 "query" : {
  "field" : {
   "title" : "+crime nothing -let"
  }
 }
}

{
 "query" : {
  "field" : {
   "title" : {
    "query" : "+crime nothing -let",
    "boost" : 20.0
   }
  }
 }
}


The identifiers query

This is a simple query that filters the returned documents to only those with the provided identifiers.
It works on the internal _uid field, so it doesn't require the _id field to be enabled.

{
 "query" : {
  "type" : "books",
  "ids" : {
   "values" : [ "10", "11", "12" ]
  }
 }
}


