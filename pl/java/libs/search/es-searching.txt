Simple Query:

curl -XGET 'localhost:9200/library/book/_search?pretty=true' -d '{
 "query" : {
  "term" : { "title" : "crime" }
 }
}'

resp:
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 0.19178301,
    "hits" : [ {
      "_index" : "library",
      "_type" : "book",
      "_id" : "4",
      "_score" : 0.19178301, "_source" : { "title": "Crime and Punishment","otitle": "????????é??? ? ?????á???","author": "Fyodor Dostoevsky","year": 1886,"characters": ["Raskolnikov", "Sofia Semyonovna Marmeladova"],"tags": [],"copies": 0, "available" : true}
    } ]
  }
}

Let's sum up the possible call types and see what the addressing looks like:
1. Request to index and type:
    curl -XGET 'localhost:9200/library/book/_search' -d @query.json

2. Request to index and all types in it:
    curl -XGET 'localhost:9200/library/_search' -d @query.json

3. Request to all indices:
    curl -XGET 'localhost:9200/_search' -d @query.json

4. Request to few indices:
    curl -XGET 'localhost:9200/library,bookstore/_search' -d @query.json
    
5. Request to multiple indices and multiple types in them:
    curl -XGET 'localhost:9200/library,bookstore/book,recipes/_search' -d @query.json


Paging and result size:

{
 "from" :  9,
 "size" : 20,
 "query" : {
  "term" : { "title" : "crime" }
 }
}

Version:
...
 "version" : true,
...
resp:
...
 "version" : 1
...

Limiting the score:
...
 "min_score" : 0.75,
...

Choosing the fields we want to return:
...
 "fields" : [ "title", "year" ],
...
resp:
...
 "fields" : {
   "title" : "..."
   "year" : 1886
 }
...
Note: ES can return stored fields only or if the "_source" field is used
  "*" - if we need all the stored fields.
  "include" : [ "prefix*" ] - if we need partial fields.
  "exclude" : [ ...]


Query types - Basic queries:

Term query:

{
 "query" : {
  "term" : {
   "title" : {
    "value" : "crime",
    "boost" : 10.0
   }
  }
 }
}

Note: the term query is not analyzed, so you need to provide the exact term that will match the term in the indexed document.
However, you can also include the boost attribute in your term query; this will affect the importance of the given term.

The terms query

{
 "query" : {
  "terms" : {
   "tags" : [ "novel", "book" ]
   "minimum_match" : 1
  }
 }
}

The match query

{
 "query" : {
  "match" : {
   "title" : "crime and punishment"
  }
 }
}

It takes the values given in the query parameter, analyzes them, and constructs the appropriate query out of them.
When using a match query, ElasticSearch will choose the proper analyzer for a field we've chosen,
so you can be sure that the terms passed to the match query will be processed by the same analyzer that was used during indexing.

Please remember that the match query (and as further explained, the multi match query) doesn't support Lucene query syntax


The Boolean match query

is a query that analyzes the provided text and makes a Boolean query out of it.

There are a few parameters that allow us to control the behavior of Boolean match queries:
operator:
    This can take the value of or or and and control what Boolean operator is used to connect the created Boolean clauses.
    The default value is or.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
fuzziness:
    Providing the value of this parameter allows one to construct fuzzy queries.
    It should take values from 0.0 to 1.0 for a string object.
    While constructing fuzzy queries, this parameter will be used to set the similarity.
prefix_length:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section below.
max_expansions:
    This allows one to control the behavior of the fuzzy query.
    For more information on the value of this parameter, please see the The fuzzy like this query section in below.
The parameters should be wrapped in the name of the field we are running the query against.
So, if we wanted to run a sample Boolean match query against the title field, we could send a query like so:

{
 "query" : {
  "match" : {
   "title" : {
    "query" : "crime and punishment",
    "operator" : "and"
   }
  }
 }
}


The phrase match query

Similar to the Boolean query, but instead of constructing the Boolean clauses from the analyzed text, it constructs a phrase query.

The following parameters are available:
slop:
    This is an integer value that defines how many unknown words can be put between terms in the text query for a match to be considered a phrase.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the query text and defaults to the default analyzer.
    
A sample phrase match query against the title field could look like the following code:
{
 "query" : {
  "match_phrase" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1
   }
  }
 }
}


The match phrase prefix query

The last type of the match query is the match phrase prefix query.
This query is almost the same as the prefix match query, but in addition, it allows prefix matches on the last term in the query text.
Also, in addition to the parameters exposed by the match phrase query, it exposes an additional one, the max_expansions parameter,
which controls how many prefixes the last terms will be rewritten to.

Our sample query changed to the match phrase prefix query could look like this:
{
 "query" : {
  "match_phrase_prefix" : {
   "title" : {
    "query" : "crime and punishment",
    "slop" : 1,
    "max_expansions" : 20
   }
  }
 }
}


The multi match query

This is the same as the match query, but instead of running against a single field, it can be run against multiple fields with the use of the fields parameter.
Of course, all the parameters you use with the match query can be used with the multi match query.
So, if we want to modify our match query to be run against the title and otitle fields, we could run the following query:
{
 "query" : {
  "multi_match" : {
   "query" : "crime punishment",
   "fields" : [ "title", "otitle" ]
  }
 }
}


The query string query

In comparison with the other queries available, the query string query supports full Apache Lucene query syntax,
so it uses a query parser to construct an actual query using the provided text. A sample query string query can look like this:
{
 "query" : {
  "query_string" : {
   "query" : "title:crime^10 +title:punishment -otitle:cat +author:(+Fyodor +dostoevsky)",
   "default_field" : "title"
  }
 }
}

You may wonder what that weird syntax in the query parameter is; we will get to it in the Lucene query syntax part of the query string query description.
As with most of the queries in ElasticSearch, the query string query provides a few parameters that allow us to control query behavior:

query:
    This specifies the query text
default_field:
    This specifies the default field the query will be executed against.
    It defaults to the "index.query.default_field property", which is by default set to "_all".
default_operator:
    This specifies the default logical operator (or/and) used when no operator is specified.
    The default value of this parameter is "or".
analyzer:
    This specifies the name of the analyzer used to analyze the query provided in the "query" parameter.
allow_leading_wildcard:
    This specifies whether a wildcard allowed as the first character of a term;
    it defaults to true.
lowercase_expand_terms:
    This specifies whether terms rewritten by the query are lowercased.
    It defaults to true.
enable_position_increments:
    This specifies whether position increments are turned on in the result query.
    It defaults to true.
fuzzy_prefix_length:
    This is the prefix length for generated fuzzy queries, and it defaults to 0.
    To learn more about it, please look at the The fuzzy query section.
fizzy_min_sim:
    This specifies the minimum similarity for fuzzy queries and defaults to 0.5.
    To learn more about it, please look at the The fuzzy query section.
phrase_slop:
    This specifies the phrase slop and defaults to 0.
    To learn more about it, please look at the The phrase match query section.
boost:
    This is the boost value used and defaults to 1.0.
analyze_wildcard:
    This specifies whether the wildcard characters should be analyzed.
    It defaults to true.
auto_generate_phrase_queries:
    This specifies whether phrase queries should be automatically generated.
    It defaults to false.
minimum_should_match:
    This controls how many of the generated Boolean clauses should match to consider a hit for a given document.
    The value should be provided as a percentage, for example 50%, which would mean that at least 50 percent of the given terms should match.
lenient:
    This parameter can take the value of true or false.
    If it is set to true, format-based failures will be ignored.

Please note that the query string query can be rewritten by ElasticSearch, and because of that, ElasticSearch allows us to pass additional parameters that control the rewrite method.
However, for more details about that process, see the Query rewrite section later.


DisMax:

In order to use the DisMax query, one should add the use_dis_max property set to true:

{
 "query" : {
  "query_string" : {
   "query" : "crime punishment",
   "fields" : [ "title", "otitle" ],
   "use_dis_max" : true
  }
 }
}


The Field query

Is the simplified version of the query string query:

{
 "query" : {
  "field" : {
   "title" : "+crime nothing -let"
  }
 }
}

{
 "query" : {
  "field" : {
   "title" : {
    "query" : "+crime nothing -let",
    "boost" : 20.0
   }
  }
 }
}


The identifiers query

This is a simple query that filters the returned documents to only those with the provided identifiers.
It works on the internal _uid field, so it doesn't require the _id field to be enabled.

{
 "query" : {
  "type" : "books",
  "ids" : {
   "values" : [ "10", "11", "12" ]
  }
 }
}

The prefix query

is similar to the term query in terms of configuration and to the multi term query when looking into its logic.
The prefix query allows us to match documents that have a value in a certain field that starts with a given prefix.

{
 "query" : {
  "prefix" : {
   "title" : {
    "value" : "cri",
    "boost" : 3.0
   }
  }
 }
}

Note: the prefix query is rewritten by ElasticSearch...


The fuzzy like this query

It finds all the documents that are similar to the provided text but works a bit differently from the more like this query because it makes use of
fuzzy strings and picks the best differencing terms produced.
For example, if we want to run a fuzzy like this query against the title and otitle fields and find all the documents similar to the crime punishment query,
we could run the following query:

{
 "query" : {
  "fuzzy_like_this" : {
   "fields" : ["title", "otitle"],
   "like_text" : "crime punishment"
  }
 }
}

The following query parameters are supported:

fields:
    This is an array of fields that the query should be run against.
    It defaults to the _all field.
like_text:
    This is a required parameter that holds the text we compare the documents to.
ignore_tf:
    This specifies whether term frequencies be ignored;
    this parameter defaults to false.
max_query_terms:
    This specifies the maximum number of query terms that will be included in a generated query.
    It defaults to 25.
min_similarity:
    This specifies the minimum similarity that differencing terms should have.
    It defaults to 0.5.
prefix_length:
    This specifies the length of the common prefix of the differencing terms.
    It defaults to 0.
boost:
    This is the boost value that will be used when boosting queries.
    It defaults to 1.
analyzer:
    This specifies the name of the analyzer that will be used to analyze the text we provided.


The fuzzy like this field query

is similar to the fuzzy like this query but works only against a single field, and because of that, it doesn't support the fields property.
Instead of specifying the fields that should be used for query analysis, we should wrap the query parameters into the field name.

{
 "query" : {
  "fuzzy_like_this_field" : {
   "title" : {
    "like_text" : "crime and punishment"
    }
  }
 }
}

The fuzzy query

The third type of fuzzy query matches documents on the basis of the edit distance algorithm that is calculated on the terms we provide against the
searched documents. This query can be expensive when it comes to CPU resources but can help us when we need fuzzy matching, for example,
when users make spelling mistakes.
In our example, let's assume that, instead of crime, our user enters cirme into the search box and we would like to run the simplest form of fuzzy query.
Such a query could look like this:

{
 "query" : {
  "fuzzy" : {
   "title" : "cirme"
  }
 }
}

And the response for this query would be as follows:
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 0.625,
    "hits" : [ {
      "_index" : "library",
      "_type" : "book",
      "_id" : "4",
      "_score" : 0.625, "_source" : {
        "title": "Crime and Punishment",
        "otitle": "????????é??? ? ?????á???",
        "author": "Fyodor Dostoevsky",
        "year": 1886,
        "characters": ["Raskolnikov", "Sofia Semyonovna Marmeladova"],
        "tags": [],
        "copies": 0,
        "available" : true
      }
    } ]
  }
}

As you can see, even though we made a typo, ElasticSearch managed to find the document we were interested in.
You can control the fuzzy query behavior by using the following parameters:


The fuzzy query

This query can be expensive when it comes to CPU resources but can help us when we need fuzzy matching, for example, when users make spelling mistakes. In our example, let's assume that, instead of crime, our user enters cirme into the search box and we would like to run the simplest form of fuzzy query
{
 "query" : {
  "fuzzy" : {
  "title" : "cirme"
  }
 }
}

You can control the fuzzy query behavior by using the following parameters:
value:
    This specifies the actual query (in case we want to pass more parameters).
boost:
    This specifies the boost value for the query. It defaults to 1.0.
min_similarity:
    This specifies the minimum similarity for a term to be counted as a match.
    In the case of string fields, this value should be between 0 and 1, both inclusive.
    For numeric fields, this value can be greater than one, for example,
    for a query with value equal to 20 and min_similarity set to 3, we would get values from 17 to 23.
    For date fields, we can have min_similarity values that include 1d, 2d, and 1m.
    These values correspond to one day, two days, and one month, and so on.
prefix_length:
    This is the length of the common prefix of the differencing terms, which defaults to 0.
max_expansions:
    This specifies the number of terms the query will be expanded to. The default value is unbounded.

The parameters should be wrapped in the name of the field we are running the query against. So, if we would like to modify the previous query and add additional parameters,
the query could look like the following code:
{
 "query" : {
  "fuzzy" : {
   "title" : {
    "value" : "cirme",
    "min_similarity" : 0.2
   }
  }
 }
}


The match all query

{
 "query" : {
  "match_all" : {}
 }
}

if we want to boost some field (title):

{
 "query" : {
  "match_all" : {
   "norms_field" : "title"
  }
 }
}


The wildcard query

Allows us to use the * and ? wildcards in the values we search for. Apart from that, the wildcard query is very similar to the term query in its body.

{
 "query" : {
  "wildcard" : {
   "title" : "cr?me"
  }
 }
}

However, you can also include the boost attribute with your wildcard query, which will affect the importance of each term that matches the given value.

{
 "query" : {
  "wildcard" : {
   "title" :
   "value" : "cr?me",
    "boost" : 20.0
   }
  }
 }
}

Please note that wildcard queries are not very performance oriented and should be avoided if possible; leading wildcards (terms starting with wildcards) should especially be avoided.
Please note that the wildcard query is rewritten by ElasticSearch, and because of that, ElasticSearch allows us to pass an additional parameter, controlling the rewrite method.


The more like this query

Allows us to get documents that are similar to the provided text.
ElasticSearch support a few parameters to define how more like this queries should work:

fields:
    This is an array of fields that the query should be run against. It defaults to the _all field.
like_text:
    This specifies a required parameter that holds the text to which we compare the documents.
percent_terms_to_match:
    This specifies the percentage of terms that must match for a document to be considered similar. It defaults to 0.30, which translates to 30 percent
min_term_freq:
    This is the minimum term frequency (for the terms in the documents) below which terms will be ignored. It defaults to 2.
max_query_terms:
    This is the maximum number of terms that will be included in a generated query; it defaults to 25.
stop_words:
    This specifies an array of words that will be ignored.
min_doc_freq:
    This specifies the minimum number of documents in which terms have to be present in order not to be ignored. It defaults to 5.
max_doc_freq:
    This specifies the maximum number of documents in which terms may be present in order not to be ignored, but the default is for it to be unbounded.
min_word_len:
    This specifies the minimum length of a single word below which it will be ignored. It defaults to 0.
max_word_len:
    This specifies the maximum length of a single word above which it will be ignored. It defaults to being unbounded.
boost_terms:
    This specifies the boost value that will be used when boosting each term; it defaults to 1.
boost:
    This specifies the boost value that will be used when boosting a query. It defaults to 1.
analyzer:
    This is the name of the analyzer that will be used to analyze the text we provided.
    

{
 "query" : {
  "more_like_this" : {
   "fields" : [ "title", "otitle" ],
   "like_text" : "crime and punishment",
   "min_term_freq" : 1,
   "min_doc_freq" : 1
  }
 }
}




