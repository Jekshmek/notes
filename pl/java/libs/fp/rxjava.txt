https://github.com/Netflix/RxJava
http://techblog.netflix.com/2013/02/rxjava-netflix-api.html

https://github.com/Netflix/RxJava/wiki
  zip, filter, map, mapMany, merge, concat
  Eledge-RxJava\02. Observable Creation, Composition, and Filtering\02_08-Filtering.mp4
  Christensen - Reactive Programming with Rx slides


ifaces:

Observer
    onNext(T)
    onCompleted(T)
    onError(Throwable t)

Subscription
    unsubscribe() // to disconnect the observable from the observer it is subscribed


internals:

Observable
    .empty()

    .create(...) // see later
    .from(T object [, Scheduler s]) // from a single simple value
    .from(Iterable<T> list [, Scheduler s])
    .from(T [] array [, Scheduler s])
    .from(Future<T> future [, Scheduler s])

    .parallel(...)
        to run in parallel
        (observable) -> { return observable.filter(...)...doOnNext((xx) -> { ... });

    .subscribe()
    .subscribe(,)
    .subscribe(,,)
    .subscribeOn(Sheduler s)
        Schedulers.newThread()
    .observeOn(Scheduler s) // if not speci-d, the subscribeOn's one will be used
        Schedulers.io()
    .onErrorResumeNext(throwable -> {... return ...})
    .doOnCompleted(() -> {
        synchronized(waitMon) {
            waitMon.notify();
        }
    })

    .soSortedList((e1, e2) -> { return e1...().compareTo(e2...); })

    // predicates
    .filter((i) -> { return some bool expr; })
    .distinct()

    // positional filtering
    .first([pred])
    .firstOrDefault("list is empty")
    .last([pred])
    .elementAt(idx)
    .elementAtOrDefault(idx, def)
    .take(num)
    .takeLast(num)

    // time based filtering
    .sample(num, TimeUnit.SECONDS)
    .timeout(num, TimeUnit) // generate onError(java.util.concurrent.TimeoutException) in case of timeout
    .amb(observable1, observable2) // select whichever observable who wins the race
    .skipUntil(observable) // skip all output from source observable until the param-observable begins to emit items
    .takeUntil(observable) // emits ...

    // transformations
    .map(op)
    .flatMap(el -> (r1, r2, ..., rn)) // ... (el) -> { return Observable... }
    .scan(initState, (curState, item) -> { ... return newState ...}) // like a fold
    .groupBy((i) -> { ... ? "ODD", "EVEN" ... }) // ... groups, maintains the order of events
        .subscribe((groupList) -> {
            // groupList.getKey();
            groupList.subscribe((x) -> { ... });
        });
    .buffer(num, TimeUnit.<whatever>)
        .subscribe((list) -> { ... })

    // conditional operations - control one evt-stream using another
    .defaultIfEmpty(value)
    .skipWhile(v -> ... bool-cond ...)
    .takeWhile(v -> ... bool-cond ...)
    .takeWhileWithIndex((v, idx) -> ... bool-cond ...)


BlockingObservable
    .from (...)
    .from (Observable o)

Observable types
* non-blocking ubservables
    - async execution supported (RxJava is a single-threaded by default)
    - unsubscribe at any point in the event stream

* blocking observables (BlockingObservable subclass)
    - events are synchronous
    - no ability to unsubscribe in the middle of event stream

* connectable observables

* resource management
* subjects


Observable.create(subscriber ->
    subscriber.setProducer(request -> {
        int idx = (int)request;
        subscriber.onNext(... idx ...);
    })
);

Observable.create(new Observable.OnSubscribe<String>() {
    @Override
    public void call(Subscriber<? super String> subscriber) {
        for (String item : collection) {
            if (subscriber.isUnsubscribed()) {
                break;
            }
            String data = item.getSomething(...);
            subscriber.onNext(... data ...);
        }
        subscriber.onCompleted();
        // ??? onError???
    }
});


observable.subscribe(new Action1<String>() {
    @Override
    public void call(String data) {
        ...
    }
});

observable.subscribe(new Subscriber<String>() {
    ...
    @Override
    public void onNext(String data) {
        ...
        if (data ...) {
            unsubscribe();
        }
    }
    ...
});

new Subscriber<StackInfo>() {
    // !!!
    @Override
    public void onStart() {
        super.onStart();
        request(nnn); // request first nnn items
        request(0) // ???
    }

    @Override
    public void onNext(StackInfo stackInfo) {
        ...
        // calculate idx
        request(idx);
    }

    @Override
    public void onCompleted() { ... }
    @Override
    public void onError(Throwable t) { ... }
}

observable.subscribe(
    // onNext
    (i) -> { ... },
    // onError
    (t) -> { ... },
    // onCompleted
    () -> { ... }
);


BehaviorSubjects<T> extends Observable<T>
// we can call it's onNext/onError/onCompleted


schedulers

- computation()
    num of threads = num of CPU cores
- currentThread()
    finished the on-going work and then invokes the handler's code for the current-thread
- immetiate()
    does not allow the on-going work to finish, but immediately invokes the handler's code for the cur-thread
- io()
    uses a thread-pool which grows as needed
- newThread()
    new thread for the each unit of work
- executor(Executor)
- executor(ScheduledExecutor)
    wrap an std-java i-face


observableFutureList = Observable.from(future);

Schedulers.computation().schedule(() -> {
    future.run();
});

observableFutureList.subscribe((list) -> {
    list.forEach((i) -> {
        System.out.println(i);
    });
});


error hanling

by default, calling the onError() results to the stream shutdown.

