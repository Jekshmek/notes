void
CCapeRulesParser::makeActionParser()
{
    ...
                makeIfP( // 3-arg test/true/false
                    makeSequenceP(makeAttrNameP() + makeCharP(L'.') + makeCharP(L'{')),
                    m_pAssignmentParser,
                    // Attr = [Value|:Binding.Attr]
                    makeSequenceP(
                        makeOptionalP(
                            makeCharP(L'?', makeA(this, &CCapeRulesParser::setOptional))
                        ) +
                        makeAttrNameP(makeA(this, &CCapeRulesParser::setAttr)) +               // !!!
                        makeAlternativeP(
                            makeCharSeqP(UNICODE_STRING_SIMPLE("=^"), makeA(this, &CCapeRulesParser::setUpperAttrAssign)) +
                            makeCharP(L'=', true)
                        ) +
                        makeAlternativeP(
                            makeIdP(makeA(this, &CCapeRulesParser::setAttrStrValue)) +         // !!!
                            makeStrP(L'"', makeA(this, &CCapeRulesParser::setAttrStrValue)) +  // !!!
                            makeStrP(L'\'', makeA(this, &CCapeRulesParser::setAttrStrValue)) + // !!!
                            makeConfixP(L'<', L'>', makeA(this, &CCapeRulesParser::setAttrStrValue)) +
    ...
}
    

// outputs are the members:
// m_strCurAttr
// m_nCurAttrIndex

void
CCapeRulesParser::setAttr(const UnicodeString &str, const CParserStream &stream)
{
    m_strCurAttr = m_vAssignmentPrefixes.back() + str;
    int nTypeIndex = m_pCurAction->getType();

    try
    {
        m_nCurAttrIndex = m_pEngine->getAttrIndex(nTypeIndex, m_strCurAttr); // !!!
        m_logger.info(UNICODE_STRING_SIMPLE("::setAttr ") + m_strCurAttr
            + UNICODE_STRING_SIMPLE(" typeIdx: ") + boost::lexical_cast<UnicodeString>(nTypeIndex)
            + UNICODE_STRING_SIMPLE(" attrIdx: ") + boost::lexical_cast<UnicodeString>(m_nCurAttrIndex)
        );

        if (-1 != m_nCurAttrIndex)
        {
            if (Attribute::AT_GROUP == m_pEngine->getSchemeValueType(nTypeIndex, m_nCurAttrIndex))
            {
                throw CParseException(UNICODE_STRING_SIMPLE("Assignment to the group attribute \"") +
                    m_strCurAttr + UNICODE_STRING_SIMPLE("\" is not allowed."), stream);
            }
            if (m_pEngine->isMultiAttribute(nTypeIndex, m_nCurAttrIndex))
            {
                // Use "Group[0].Attr" attribute instead of "Group.Attr" in the left part of attr assignment
                ++m_nCurAttrIndex;

                m_logger.info(UNICODE_STRING_SIMPLE("::setAttr curAttrIndex: ") + boost::lexical_cast<UnicodeString>(m_nCurAttrIndex));
                m_strCurAttr = m_pEngine->getAttrNameByIndex(nTypeIndex, m_nCurAttrIndex);
            }
        }
    }
    catch (const CException &e)
    {
        throw CParseException(UNICODE_STRING_SIMPLE("CCapeRulesParser::setAttr: ") + e.getMessage(), stream);
    }
}


void
CCapeRulesParser::setAttrStrValue(const UnicodeString &strVal, const CParserStream &stream)
{
    if (m_bMakeUpper)
        setAttrValue(UnicodeString(strVal).toUpper(), stream, CAttributeValue::STRING); // TODO: need to take care of TR locale here.
    else
        setAttrValue(strVal, stream, CAttributeValue::STRING);
}


//
// from the CCapeRulesParser .h
//
//    RhsActionPtr m_pCurAction;

void
CCapeRulesParser::setAttrValue(const UnicodeString &strVal, const CParserStream &stream, int nValueType)
{
    try
    {
        AttributeValuePtr pVal = m_pEngine->allocateAttribute(m_pCurAction->getType(), m_nCurAttrIndex,
            nValueType, strVal);
        m_pCurAction->addAttribute(m_strCurAttr, pVal); // !!!
    }
    catch (const CException &e)
    {
        throw CParseException(UNICODE_STRING_SIMPLE("CCapeRulesParser::setAttrValue: ") + e.getMessage(), stream);
    }
    m_strCurAttr.remove();
    m_nCurAttrIndex = -1;
    m_bMakeUpper = false;
    m_bOptional = false;
}



inline bool
CRhsAction::addAttribute(const UnicodeString &strAttrName, const AttributeValuePtr &pValue)
{
    if (!hasAttrReference(strAttrName))
    {
        ReferencePtr pRef = std::make_shared<CReference>(CReference::TYPE_ATTR);
        pRef->setTo(strAttrName);
        pRef->setFrom(pValue);
        m_vReferences.push_back(pRef); // !!!
        return true;
    }
    return false;
}


// Later will be used by (at the cape sentence-processing, not at the cape rules parsing)

CAnnotation *
CRhsAction::execute(const CReferenceBinding &annSet, const CFSMInstance *pFSMInstance, CSentence *pSentence) const
{
    CCAPEEngine *pEngine = pSentence->getEngine();
    CCAPEAnnotation *pAnnotation = pEngine->allocateAnnotation(m_nTypeIndex);
    pAnnotation->setRule(m_pRule);
    ...
    // Process references and attributes
    for (vector<ReferencePtr>::const_iterator iRef = m_vReferences.begin(); iRef != m_vReferences.end(); ++iRef)
    {
        CReference *pRef = iRef->get();
        if (pRef->getReferenceType() == CReference::TYPE_ATTR &&
            pRef->getReferenceMode() == CReference::MODE_DEFAULT)
        {
            try
            {
                const UnicodeString &strAttrName = pRef->getTo();
                const AttributeValuePtr &pAttrValue = pRef->getFrom();
                pAnnotation->setAttribute(strAttrName, pAttrValue); // !!!
            }
            catch (const fx::CException &e)
            {
                throw CAnnotationException(UNICODE_STRING_SIMPLE("Cannot set attribute \"") + pRef->getTo() +
                    UNICODE_STRING_SIMPLE("\": ") + e.getMessage(),
                    pAnnotation);
            }
            continue;
        }
        ...
    }
    ...
}


// at the annotaion static-lib

void
CAnnotation::setAttribute(const UnicodeString &strAttrName, const AttributeValuePtr &pAttrValue)
{
    int nAttrIndex = m_pAnnotationEngine->getAttrIndex(m_nTypeIndex, strAttrName); // !!! should be pushed by the CTypeInfo c-tor of the AnnotEng
    if (-1 != nAttrIndex)
    {
        setAttribute(nAttrIndex, pAttrValue); // !!!
    }
    else
    {
        m_vTempAttrs.insert_or_replace(make_pair(strAttrName, pAttrValue));
    }
}


int
CAnnotationEngine::getAttrIndex(int nTypeIndex, const UnicodeString& strAttrName) const
{
    assert(nTypeIndex >= 0 && nTypeIndex < (int)m_vTypes.size());

    if (isTempAttr(strAttrName))
        return -1;

    const CTypeInfo& type = m_vTypes[nTypeIndex];
    MSI::const_iterator it = type.m_mapAttrs.find(strAttrName);
    if (it != type.m_mapAttrs.end())
    {
        return it->second; // !!! should be pushed by the CTypeInfo c-tor of the AnnotEng
    }
    throw CException(UNICODE_STRING_SIMPLE("Object type \"") +
        type.m_strName +  UNICODE_STRING_SIMPLE("\" does not support attribute \"") + strAttrName + L'"');
}


void
CAnnotation::setAttribute(int nAttrIndex, const AttributeValuePtr &pAttrValue)
{
    assert(!m_pAnnotationEngine->isMultiAttribute(m_nTypeIndex, nAttrIndex));

    m_vAttrs.insert_or_replace(CAttrValueInfo(nAttrIndex, false, true, false, pAttrValue)); // !!!

    updateGroupCount(nAttrIndex);
    processCompoundAttr(nAttrIndex, pAttrValue);
}


Later it (m_vAttrs) will be picked by:
// TODO: excercise - find usages


void
CAnnotation::writeAttrs()
{
    for (MAPAttributes::iterator i = m_vAttrs.begin(); i != m_vAttrs.end(); ++i)
    {
        if (i->m_bDeleted)
        {
            m_pAnnotationEngine->deleteAttribute(m_nTypeIndex, i->m_nAttrIndex, m_pObj);
        } else if (i->m_bNew && i->m_pValue)
        {
            m_pAnnotationEngine->writeAttribute(m_nTypeIndex, i->m_nAttrIndex, m_pObj, i->m_pValue);
            i->m_bNew = false;
        }
    }
}


void
CAnnotationEngine::writeAttribute(int nTypeIndex, int nAttrIndex, nlp::foundation::Object *pObj, const AttributeValuePtr &pValue)
{
    const CAttrInfo &attr = m_vTypes[nTypeIndex].m_vAttrIndexes[nAttrIndex]; // !!! we grab the stuff, filled by CTypeInfo c-tor here !!!

    if (-1 != attr.m_nCompoundIndex) // Don't save sub-attributes. They are saved via compound attribute
        return;

    const Attribute *pAttr = attr.m_pAttr;

    switch (pAttr->getValueType())
    {
    case Attribute::AT_STRING:
        pAttr->setValue(pObj, pValue->getStringValue(), static_cast<nlp::UWord>(attr.m_nGroupOffset), ); // !!!
        break;
    case Attribute::AT_DWORD:
    case Attribute::AT_WORD:
        pAttr->setValue(pObj, pValue->getIntegerValue(), static_cast<nlp::UWord>(attr.m_nGroupOffset));
        break;
    case Attribute::AT_FLOAT:
        pAttr->setValue(pObj, pValue->getFloatValue(), static_cast<nlp::UWord>(attr.m_nGroupOffset));
        break;
    case Attribute::AT_BYTE:
        pAttr->setValue(pObj, (nlp::Byte)(pValue->getBoolValue() ? 1 : 0), static_cast<nlp::UWord>(attr.m_nGroupOffset));
        break;
    case Attribute::AT_QWORD:
    case Attribute::AT_ENUM:
    case Attribute::AT_MASK:
    case Attribute::AT_COMPOUND:
        pAttr->setValue(pObj, pValue->getQWordValue(), static_cast<nlp::UWord>(attr.m_nGroupOffset));
        break;
    case Attribute::AT_GROUP:
        // All operations with attributes of a group affect the group attribute (sets the count value).
        // Therefore, if we try to set group attribute then just delete group content. All subsequent
        // setAttribute() calls will set clean values of attributes of the group.
        pAttr->deleteValue(pObj);
        break;
    default:
        throw CException("Unknown attribute type");
    }
}


// at CAnnotationEngine

protected:
    typedef std::map<UnicodeString, int, UStrLess> MSI;
    typedef std::map<UnicodeString, UnicodeString, UStrLess> MSS;
    typedef std::map<UnicodeString, std::pair<CachedConstraintPtr, int>, UStrLess> MSCI;
    struct CAttrInfo
    {
        CAttrInfo(const nlp::foundation::Attribute *pAttr, const UnicodeString &strName,
            int nCompoundIndex, int nGroupIndex = -1, int nGroupOffset = -1
        )
        :
              m_strName(strName)
            , m_nGroupIndex(nGroupIndex)
            , m_nGroupOffset(nGroupOffset)
            , m_nSize(1)
            , m_nCompoundIndex(nCompoundIndex)
            , m_nCompoundCount(0)
            , m_Type(pAttr->getValueType())
            , m_pAttr(pAttr)
        {
            if (-1 != m_nCompoundIndex && -1 != m_nGroupOffset)
                m_nCompoundIndex += m_nGroupOffset + 1; // ???
        }

        bool operator == (const CAttrInfo& attr) const
        {
            return m_Type == attr.m_Type && m_nGroupIndex == attr.m_nGroupIndex &&
                m_nGroupOffset == attr.m_nGroupOffset && m_strName == attr.m_strName;
        }

        const nlp::foundation::Attribute* getAttr() const
        {
            return m_pAttr;
        }

        UnicodeString m_strName; // attr name

        int m_nGroupIndex;       // index of a group-attr
        int m_nGroupOffset;      // offset [0], [1], ... -1 for non-group items
        int m_nSize;             // size of attrs in a group (??? MAX_GROUP_ITEMS or MAX_GROUP_ITEMS + 1)

        int m_nCompoundIndex;    // index of a compound-attr
                                 // ??? (why do we add (m_nGroupOffest + 1 in c-tor) for [0], [1], ... el-s of the group
        int m_nCompoundCount;    // count of compound sub-attrs

        nlp::foundation::Attribute::ValueType m_Type;
        const nlp::foundation::Attribute *m_pAttr;

        // need to add bool m_bUseAllGroupItems and specify it at CTypeInfo c-tor
    };

    struct CTypeInfo
    {
        CTypeInfo(const UnicodeString &strName, const nlp::foundation::TypeInfo *pType);

        UnicodeString m_strName;
        nlp::Identifier m_idType;
        nlp::Identifier m_idLastSubType;
        std::vector<CAttrInfo> m_vAttrIndexes; // m_vAttrByIndices is much better name
        MSI m_mapAttrs;
        int m_nTextAttr;
        int m_nStartPosAttr;
        int m_nEndPosAttr;

        void logDebug(const Logger &logger);
    };



// ??? what is the real impl ???

nlp::foundation::Attribute

    virtual void setValue(Object* pObj, const icu::UnicodeString& val, nlp::UWord index = MAX_INDEX) const = 0;


